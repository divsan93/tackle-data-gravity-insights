////
the idea behind this guide is: someone scanned their project, now what?
with the guide they can interactively explore their software and find some interesting insights
try it out with  :play http://guides.neo4j.com/jqa
please add interesting concepts / queries from your blog posts, documentation etc.
////
= DGI Demo Guide

== Introduction

Tackle Data Gravity Insights is a new way to gain insights into your monolithic application code so that you can better refactor it into domain driven microservices. It takes a wholistic approach to application modernization and refactoring by triangulating between code, and, data, and transactional boundaries.

Application modernization is a complex topic with refactoring being the most complicated undertaking. Current tools only look at the application source code or only at the runtime traces when refactoring. This, however, yields a myopic view that doesn't take into account data relationships and transactional scopes. This project hopes to join the three views of application, data, and transactions into a 3D view of the all of the application relationships so that you can easily discover application domains of interest and refactor them into microservices. Accordingly, DGI consists of three key components:

- *Call-/Control-/Data-dependency Analysis (code2graph):* This is a source code analysis component that extracts various static code interaction features pertaining to object/dataflow dependencies and their respective lifecycle information. It presents this information in a graphical format with Classes as nodes and their dataflow, call-return, and heap-dependency interactions edges.

- *Schema:* This component of DGI infers the schema of the underlying databases used in the application. It presents this information in a graphical format with database tables and columns as nodes and their relationships (e.g., foreign key, etc.) as edges.

- *Transactions to graph (tx2graph):* This component of DGI leverages Tackle-DiVA to perform a data-centric application analysis. It imports a set of target application source files (*.java/xml) and provides following analysis result files. It presents this information in a graphical format with database tables and classes as nodes and their transactional relationships as edges.


== Getting Started

If you haven't already, scan your project with our getting started guide.

If you have your Neo4j instance running on the scanned data you can get a quick overview on the data model with this query

[source,cypher]
----
call db.schema.visualization()
----

This view gives us an overview of the the nodes and edges in the neo4j graph

For a tabular overview use this:

[source,cypher]
----
MATCH (n) 
// a collection of multiple labels is turned into rows
UNWIND labels(n) as label
RETURN label, count(*)
ORDER BY count(*) asc
----

== Interesting Information

=== How many classes are contained in the project?

This query counts all classes nodes in the project.

[source,cypher]
----
MATCH (t:ClassNode)
RETURN count(t)
----

=== How many database tables are contained in the project?

This query counts all SQLTable nodes in the project.

[source,cypher]
----
MATCH (t:SQLTable)
RETURN count(t)
----

== Relationships

=== A summary of relationship types

First, let's gather all the relationship types:

[source,cypher]
----
CALL db.relationshipTypes()
----

You'll obtain the following:

[text]
----
╒════════════════════════╕
│"relationshipType"      │
╞════════════════════════╡
│"FOREIGN_KEY"           │
├────────────────────────┤
│"TRANSACTION_READ"      │
├────────────────────────┤
│"TRANSACTION_WRITE"     │
├────────────────────────┤
│"HEAP_DEPENDENCY"       │
├────────────────────────┤
│"DATA_DEPENDENCY"       │
├────────────────────────┤
│"CALL_RETURN_DEPENDENCY"│
└────────────────────────┘
----

== Immutability

=== Labels all classes with an immutable state as "Immutable"

[source,cypher]
----
MATCH (immutable:Class)-[:DECLARES]->(field:Field)<-[:WRITES]-(accessorMethod)
WHERE field.visibility = 'private'

WITH immutable, collect(accessorMethod) AS accessorMethods
WHERE ALL (accessorMethod IN accessorMethods WHERE accessorMethod:Constructor)

SET immutable:Immutable
RETURN immutable
----

////
 == Metrics (TODO)

TODO

== Cycles (TODO)

TODO

////
== Coupling

// todo mark types of package with ":Investigation" label
// todo 

=== Mark types to investigate

Mark the types in one package to be investigated.
So instead of always checking this condition: `WHERE has(t.byteCodeVersion) AND t.fqn STARTS WITH {package}` we can just match on the `:Investigate` label.

++++
<input style="display:inline;width:30%;" value-for="package" class="form-control" value="some.package." size="40">
++++

[source,cypher]
----
MATCH (t:Type:File)<-[:DEPENDS_ON]-(dependent:Type)
 WHERE has(t.byteCodeVersion) AND t.fqn STARTS WITH {package}
SET t:Investigate
----

=== Add fan-in to type


Add a property 'fanIn' to a Type with the number of other types depending on them

[source,cypher]
----
MATCH (t:Type:File:Investigate)<-[:DEPENDS_ON]-(dependent:Type)
WITH t, count(dependent) AS dependents
SET t.fanIn = dependents
RETURN t.fqn AS type
----

=== Add fan-out to type

Add a property 'fanOut' to a Type with the number of other types they depend on

[source,cypher]
----
MATCH (t:Type:File:Investigate)-[:DEPENDS_ON]->(dependency:Type)

WITH t, count(dependency) AS dependencies
SET t.fanOut = dependencies

RETURN t.fqn AS Type, t.fanOut AS fanOut
 ORDER BY fanOut DESC
----

=== Add default fan-out

Add a property 'fanOut' to all Types without fanOut property

[source,cypher]
----
MATCH (t:Type:File)
 WHERE NOT has(t.fanOut)
SET t.fanOut = 0
RETURN t.fqn AS type
----

=== Add default fan-out

Add a property 'fanIn' to all Types without fanIn property

[source,cypher]
----
MATCH (t:Type:File:Investigate)
 WHERE NOT has(t.fanIn)
SET t.fanIn = 0
RETURN t.fqn AS type
----

=== Add type-coupling

Add a property `typeCoupling` to a `Type` as sum of `fanIn` and `fanOut`

[source,cypher]
----
MATCH (t:Type:File:Investigate)

SET t.typeCoupling = t.fanIn + t.fanOut

RETURN t.fqn AS type, t.typeCoupling AS typeCoupling,
      t.fanIn AS fanIn, t.fanOut AS fanOut
 ORDER BY typeCoupling DESC, fanIn DESC
----

=== Add in-package fan-out

Add a property 'inPackageFanOut' to a Type with the number of other types they depend on

[source,cypher]
----
MATCH (p1:Package)-[:CONTAINS]->(t:Type:File:Investigate)-[:DEPENDS_ON]->
      (dependency:Type)<-[:CONTAINS]-(p2:Package)
 WHERE p1 = p2 AND NOT dependency.fqn CONTAINS '$'

WITH t, count(dependency) AS dependencies
SET t.inPackageFanOut = dependencies

RETURN t.fqn AS type, t.inPackageFanOut AS fanOut
 ORDER BY fanOut DESC
----

=== Add in-package fan-in

Add a property `inPackageFanIn` to a `Type` with the number of other types they depend on

[source,cypher]
----
MATCH (p1:Package)-[:CONTAINS]->(t:Type:File:Investigate)<-[:DEPENDS_ON]-
     (dependency:Type)<-[:CONTAINS]-(p2:Package)
 WHERE p1 = p2 AND NOT dependency.fqn CONTAINS '$'

WITH t, count(dependency) AS dependencies

SET t.inPackageFanIn = dependencies

RETURN t.fqn AS type, t.inPackageFanIn AS fanIn
 ORDER BY fanIn DESC
----

=== Add type-in-package coupling

Add a property `typeInPackageCoupling` to a `Type` as sum of `fanIn` and `fanOut`

[source,cypher]
----
MATCH (t:Type:File:Investigate)

SET t.typeInPackageCoupling = t.inPackageFanIn + t.inPackageFanOut

RETURN t.fqn AS type, t.typeInPackageCoupling AS typeCoupling,
      t.inPackageFanIn AS FanIn, t.inPackageFanOut AS fanOut
 ORDER BY typeCoupling DESC, fanIn DESC
----


== Unit Tests: Validate Assertions

=== Label Assert Methods

Unit Tests should have one (logical) assert per test method. 
Because also some methods of a mocking framework count as asserts, we want to label them. 

Here is an example for Mockito:

Label all assertion methods with name "verify*" declared by "org.mockito.Mockito" with `Junit4` and `Assert`

[source,cypher]
----
MATCH (assertType:Type)-[:DECLARES]->(assertMethod)
 WHERE assertType.fqn = 'org.mockito.Mockito'
 AND assertMethod.signature CONTAINS 'verify'
SET assertMethod:Junit4:Assert
RETURN assertMethod
----

Also the org.junit.Assert.fail method counts as an assert too:

[source,cypher]
----
MATCH (assertType:Type)-[:DECLARES]->(assertMethod)
 WHERE assertType.fqn = 'org.junit.Assert'
 AND assertMethod.signature starts with 'void fail'
SET assertMethod:Junit4:Assert
RETURN assertMethod
----

TODO

[source,cypher]
----
----

== (Unit) Test Coverage

=== Test Coverage

Test coverage is a wide field. 
There are lots of discussions about Unit Tests and Test Coverage. 

There is a https://github.com/kontext-e/jqassistant-plugins/tree/master/jacoco[JaCoCo Plugin by Kontext E] for importing JaCoCo test coverage results into the jQAssistant database. 
With all information in one database, you may define your Test Coverage rules (and exceptions from the rules) in a very flexible way. 

Here is one example. 
It is based on methods and their complexity: more complex methods need more test coverage, because the probability for bugs is higher in more complex methods - as a rule of thumb. 

=== Define Test Coverage Goals

So we define two ranges of method complexity based on the number of branches:

[source,cypher]
----
CREATE (medium:TestCoverageRange { complexity : 'medium', min : 4, max : 5, coverage : 80 })
CREATE (high:TestCoverageRange { complexity : 'high', min : 6, max : 999999, coverage : 90 })
RETURN medium, high
----

=== Find Methods with too low Coverage

Now we can find methods with a too low test coverage:

[source,cypher]
----
MATCH (tcr:TestCoverageRange)
WITH tcr.min AS mincomplexity, tcr.max AS maxcomplexity, tcr.coverage AS coveragethreshold

MATCH (cl:Jacoco:Class)--(m:Jacoco:Method)--(c:Jacoco:Counter {type: 'COMPLEXITY'})
 WHERE c.missed + c.covered >= mincomplexity AND c.missed + c.covered <= maxcomplexity

WITH m AS method, cl.fqn AS fqn, m.signature AS signature,
    c.missed + c.covered AS complexity, coveragethreshold

MATCH (m)--(branches:Jacoco:Counter {type: 'BRANCH'})
 WHERE m = method
WITH *, branches.covered * 100 / (branches.covered + branches.missed) AS coverage
WHERE coverage < coveragethreshold

RETURN complexity, coveragethreshold, coverage, fqn, signature
 ORDER BY complexity, coverage
----

=== Add Exceptions from Rule

And add some exceptions from this rule:

* Methods equals() and hashCode() are generated by an IDE and need not to be tested
* For some reason we don’t want measure test coverage for the ui package
* And the `StringTool.doSomethingwithStrings` method should also be excluded
* Oh, and by the way we know that there are 10 other violations that we want to skip for now + (but we swear to handle this Technical Debt in the next spring)

[source,cypher]
----
MATCH (tcr:TestCoverageRange)

WITH tcr.min AS mincomplexity, tcr.max AS maxcomplexity, tcr.coverage AS coveragethreshold

MATCH (cl:Jacoco:Class)--(m:Jacoco:Method)--(c:Jacoco:Counter {type: 'COMPLEXITY'})
 WHERE c.missed + c.covered >= mincomplexity AND c.missed + c.covered <= maxcomplexity
 AND NOT m.signature IN ['boolean equals(java.lang.Object)', 'int hashCode()']
 AND NOT(cl.fqn STARTS WITH 'de.kontext_e.demo.ui')
 AND NOT(cl.fqn = 'de.kontext_e.demo.tools.StringTool'
 AND m.signature = 'java.lang.String doSomethingwithStrings(java.lang.String)')

WITH m AS method, cl.fqn AS fqn, m.signature AS signature, c.missed+c.covered AS complexity, coveragethreshold AS coveragethreshold

MATCH (m)--(branches:Jacoco:Counter {type: 'BRANCH'})
 WHERE m=method AND branches.covered*100/(branches.covered+branches.missed) < coveragethreshold
RETURN complexity, coveragethreshold, branches.covered*100/(branches.covered+branches.missed) AS coverage, fqn, signature
 ORDER BY complexity, coverage
 SKIP 10
----
== Special case: Frequently changed classes

Maybe it’s also a good idea to have a *higher Test Coverage for frequently changed classes*. 
Using the https://github.com/kontext-e/jqassistant-plugins/tree/master/git[Git Plugin by Kontext E] there is a way to test this:

[source,cypher]
----
MATCH (c:Git:Commit)-[:CONTAINS_CHANGE]->(change:Git:Change)-[:MODIFIES]->(f:Git:File)
WHERE f.relativePath=~'.*.java'
AND NOT f.relativePath CONTAINS 'ui'
WITH count(c) AS cnt, replace(f.relativePath, '/','.') AS gitfqn
ORDER BY cnt DESC
LIMIT 10
MATCH (class:Java:Class)
WHERE gitfqn CONTAINS class.fqn
WITH cnt, class.fqn AS classfqn
MATCH (cl:Jacoco:Class)--(m:Jacoco:Method)--(c:Jacoco:Counter {type: 'COMPLEXITY'})
WHERE classfqn=cl.fqn
AND c.missed+c.covered > 3
AND NOT(m.signature ='boolean equals(java.lang.Object)')
AND NOT(m.signature ='int hashCode()')
WITH m AS method, cl.fqn AS fqn, m.signature AS signature, c.missed+c.covered AS complexity
MATCH (m)--(branches:Jacoco:Counter {type: 'BRANCH'})
WHERE m=method
AND branches.covered*100/(branches.covered+branches.missed) < 90
RETURN DISTINCT fqn, signature, complexity, branches.covered*100/(branches.covered+branches.missed) AS coverage
ORDER BY fqn
SKIP 3
----

For the 10 most often changed Java files except the ones in the ui package the Test Coverage for branches should not be lower than 90 percent for methods with more than 3 branches - with three unnamed exceptions from this rule.
== Encapsulation

=== Label types with internal FQNs as Internal
:fqn_internal: pass:a['<span value-key="fqn_internal">.internal.</span>']

++++
<input style="display:inline;width:30%;" value-for="fqn_internal" class="form-control" value=".internal." size="40">
++++

[source,cypher]
----
MATCH (t:Type) WHERE t.fqn CONTAINS {fqn_internal}
SET t:Internal
----
=== API/SPI types must not extend/implement internal types

[source,cypher]
----
MATCH
    (class:Class)-[:EXTENDS|IMPLEMENTS]->(supertype:Type:Internal)
WHERE NOT class:Internal
RETURN
    DISTINCT class as extendsInternal
----
=== API/SPI methods must not expose internal types
[source,cypher]
----
// return values
MATCH
    (class:Type)-[:DECLARES]->(method:Method)
WHERE
    NOT class:Internal
    AND method.visibility IN ["public","protected"]
    AND (exists ((method)-[:RETURNS]->(:Type:Internal)) OR 
         exists ((method)-[:`HAS`]->(:Parameter)-[:OF_TYPE]->(:Internal)))
RETURN
    method
----
=== API/SPI fields must not expose internal types

[source,cypher]
----
MATCH
    (class:Class:Internal)-[:DECLARES]->(field)-[:OF_TYPE]->(fieldtype:Type:Internal)
WHERE
    AND field.visibility IN ["public","protected"]
RETURN
    class as internalClass, field, fieldtype as internalType
----
== Resources

* https://jqassistant.org/blog/releases/[Releases]
* https://jqassistant.org/get-started/[Get Started / Download]
* http://buschmais.github.io/jqassistant/doc/1.2.0/[Documentation]
* http://github.com/buschmais/jqassistant[GitHub]
* https://github.com/kontext-e/jqassistant-plugins[jQA Plugins by Kontext E]
* https://groups.google.com/forum/#!forum/jqassistant[Google Group]
* http://stackoverflow.com/questions/tagged/jqassistant[Stackoverflow]